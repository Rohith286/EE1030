import ctypes
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Load the shared library (adjust the path if necessary)
try:
    matlib = ctypes.CDLL('./mat4.so')
except OSError as e:
    print("Error loading shared library:", e)
    exit(1)

# Define argument and return types for the createMat function
matlib.createMat.argtypes = [ctypes.c_int, ctypes.c_int]
matlib.createMat.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_double))

# Define argument and return types for printMat function
matlib.printMat.argtypes = [ctypes.POINTER(ctypes.POINTER(ctypes.c_double)), ctypes.c_int, ctypes.c_int]

# Define argument and return types for Matscale function
matlib.Matscale.argtypes = [ctypes.POINTER(ctypes.POINTER(ctypes.c_double)), ctypes.c_int, ctypes.c_int, ctypes.c_double]
matlib.Matscale.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_double))

# Define argument and return types for Matunit function
matlib.Matunit.argtypes = [ctypes.POINTER(ctypes.POINTER(ctypes.c_double)), ctypes.c_int]
matlib.Matunit.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_double))

# Define argument and return types for Matsub function
matlib.Matsub.argtypes = [ctypes.POINTER(ctypes.POINTER(ctypes.c_double)), ctypes.POINTER(ctypes.POINTER(ctypes.c_double)), ctypes.c_int, ctypes.c_int]
matlib.Matsub.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_double))

def to_ctypes_matrix(np_array):
    """Convert a numpy array to ctypes 2D pointer array."""
    ctype_matrix = (ctypes.POINTER(ctypes.c_double) * np_array.shape[0])()
    for i in range(np_array.shape[0]):
        row = (ctypes.c_double * np_array.shape[1])(*np_array[i])
        ctype_matrix[i] = row
    return ctype_matrix

# Vectors a and b
a = np.array([[1.0], [1.0], [2.0]])  # Vector a: [1, 1, 2]^T
b = np.array([[2.0], [1.0], [-2.0]])  # Vector b: [2, 1, -2]^T

# Convert to ctypes
a_ctypes = to_ctypes_matrix(a)
b_ctypes = to_ctypes_matrix(b)

# a) 6a
try:
    scaled_a = matlib.Matscale(a_ctypes, 3, 1, 6.0)
    unit_scaled_a = matlib.Matunit(scaled_a, 3)
except Exception as e:
    print("Error in computing unit vector for 6a:", e)
    exit(1)

# b) 2a - b
try:
    scaled_two_a = matlib.Matscale(a_ctypes, 3, 1, 2.0)
    two_a_minus_b = matlib.Matsub(scaled_two_a, b_ctypes, 3, 1)
    unit_two_a_minus_b = matlib.Matunit(two_a_minus_b, 3)
except Exception as e:
    print("Error in computing unit vector for 2a - b:", e)
    exit(1)

# Convert results to numpy arrays for plotting
unit_scaled_a_np = np.array([unit_scaled_a[i][0] for i in range(3)])
unit_two_a_minus_b_np = np.array([unit_two_a_minus_b[i][0] for i in range(3)])

def line_gen(A, B):
    len = 10
    dim = A.shape[0]
    x_AB = np.zeros((dim, len))
    lam_1 = np.linspace(0, 1, len)
    for i in range(len):
        temp1 = A + lam_1[i] * (B - A)
        x_AB[:, i] = temp1.T
    return x_AB

# Origin for line generation
origin = np.array([0.0, 0.0, 0.0])

# Generate points for the line between origin and the vectors
line_6a = line_gen(origin, unit_scaled_a_np)
line_2a_minus_b = line_gen(origin, unit_two_a_minus_b_np)

# 3D Plotting
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot lines generated by line_gen
ax.plot(line_6a[0, :], line_6a[1, :], line_6a[2, :], label='Line to Unit Vector (6a)', color='r')
ax.plot(line_2a_minus_b[0, :], line_2a_minus_b[1, :], line_2a_minus_b[2, :], label='Line to Unit Vector (2a - b)', color='b')

# Plot unit vectors as arrows
ax.quiver(*origin, *unit_scaled_a_np, color='r', label='Unit vector in direction of 6a', arrow_length_ratio=0.1)
ax.quiver(*origin, *unit_two_a_minus_b_np, color='b', label='Unit vector in direction of 2a - b', arrow_length_ratio=0.1)

# Plot settings
ax.set_xlim([-1, 1])
ax.set_ylim([-1, 1])
ax.set_zlim([-1, 1])
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

# Add legend
plt.legend()

# Show plot
plt.show()
